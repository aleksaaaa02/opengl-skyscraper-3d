#include "scene_node.h"

void SceneNode::AddChild(const Mesh& mesh)
{
	children.emplace_back(std::make_unique<SceneNode>(mesh));
	children.back() -> parent = this;
}

SceneNode::SceneNode(const Mesh& mesh) : Model(mesh)
{

}

SceneNode::SceneNode(const std::vector<Vertex>& vertices, const std::vector<unsigned int>& indices) : Model(Mesh(vertices, indices)) {
}
void SceneNode::DrawSelfAndChild(Shader& shader)
{ 
	shader.setMat4("model", Trans.getLocalModelMatrix());
	Draw(shader);
	
	for(auto&& child : children)
	{
		child -> DrawSelfAndChild(shader);
	}	
}

SceneNode::~SceneNode() = default;
#pragma once
#ifndef SCENE_NODE_H
#define SCENE_NODE_H

#include "model.h"
#include "mesh.h"
#include "transform.h"
#include <glm/glm.hpp>
#include <list>
#include <memory>


class SceneNode : public Model {
	std::list<std::unique_ptr<SceneNode>> children;
	SceneNode* parent = nullptr;
public:
	Transform Trans;
	void AddChild(const Mesh &mesh);
	void DrawSelfAndChild(Shader& shader);
	SceneNode(const std::vector<Vertex>& vertices, const std::vector<unsigned int>& indices);
	SceneNode(const Mesh& mesh);
	~SceneNode();
};

#endif // DEBUG

#include "model.h"
void Model::Draw(Shader& shader) 
{
		mesh.Draw(shader);
}

Model::Model(const Mesh& mesh) : mesh(mesh)
{

}

Model::~Model() = default;

#pragma once
#ifndef MODEL_H
#define MODEL_H

#include <vector>
#include "mesh.h"
#include <GL/glew.h>

class Model {
protected:
	Mesh mesh;
	
public:
	void Draw(Shader& shader);
	Model(const Mesh& mesh);
	Model() = default;
	~Model();
};

#endif // !DEBUG

#include "mesh.h"

Mesh::Mesh(const std::vector<Vertex> &vertices, const std::vector<unsigned int> &indices)
{
	this -> vertices = vertices;
	this -> indices = indices;

	meshSetup();
}

Mesh::Mesh() = default;

void Mesh::Draw(Shader &shader) const {
	glBindVertexArray(VAO);
	glDrawElements(GL_TRIANGLES, static_cast<unsigned int>(indices.size()), GL_UNSIGNED_INT, 0);
	glBindVertexArray(0);
}

void Mesh::meshSetup()
{
	
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);

	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices[0], GL_STATIC_DRAW);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &indices[0], GL_STATIC_DRAW);

	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
	glEnableVertexAttribArray(0);

	glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Colors));
	glEnableVertexAttribArray(1);

	glBindVertexArray(0);
}

Mesh::~Mesh() 
{
	glDeleteBuffers(1, &VBO);
	glDeleteBuffers(1, &EBO);
	glDeleteVertexArrays(1, &VAO);
}
#pragma once
#ifndef MESH_H 
#define MESH_H 

#include <vector>
#include <glm/glm.hpp>
#include <GL/glew.h>
#include "shader.h"

struct Vertex  {
	glm::vec3 Position;
	glm::vec4 Colors;
};

class Mesh {
	std::vector<Vertex> vertices;
	std::vector<unsigned int> indices;
	void meshSetup();
	unsigned int VBO, EBO;

public:
	unsigned int VAO;
	Mesh(const std::vector<Vertex> &vertices, const std::vector<unsigned int> &indices);
	Mesh();
	~Mesh();
	void Draw(Shader &shader) const;
};

#endif 

